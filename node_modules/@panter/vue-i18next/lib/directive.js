'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-disable no-param-reassign, no-unused-vars */

exports.bind = bind;
exports.update = update;

var _utils = require('./utils');

function equalLanguage(el, vnode) {
  var vm = vnode.context;
  return el._i18nLanguage === vm.$i18n.i18next.language;
}

function equalValue(value, oldValue) {
  if (value === oldValue) {
    return true;
  } else if (value && oldValue) {
    return value.path === oldValue.path && value.language === oldValue.language && value.args === oldValue.args;
  }
}

function assert(vnode) {
  var vm = vnode.context;

  if (!vm.$i18n) {
    (0, _utils.warn)('No VueI18Next instance found in the Vue instance');
    return false;
  }

  return true;
}

function parseValue(value) {
  var path = void 0;
  var language = void 0;
  var args = void 0;

  if (typeof value === 'string') {
    path = value;
  } else if (toString.call(value) === '[object Object]') {
    path = value.path;
    language = value.language;
    args = value.args;
  }

  return { path: path, language: language, args: args };
}

function t(el, binding, vnode) {
  var value = binding.value;

  var _parseValue = parseValue(value),
      path = _parseValue.path,
      language = _parseValue.language,
      args = _parseValue.args;

  if (!path && !language && !args) {
    (0, _utils.warn)('v-t: invalid value');
    return;
  }

  if (!path) {
    (0, _utils.warn)('v-t: "path" is required');
    return;
  }

  if (language) {
    (0, _utils.deprecate)('v-t: "language" is deprecated.Use the "lng" property in args.\n      https://www.i18next.com/overview/configuration-options#configuration-options');
  }

  var vm = vnode.context;
  el.textContent = vm.$i18n.i18next.t(path, _extends({}, language ? { lng: language } : {}, args));

  el._i18nLanguage = vm.$i18n.i18next.language;
}

function bind(el, binding, vnode) {
  if (!assert(vnode)) {
    return;
  }

  t(el, binding, vnode);
}

function update(el, binding, vnode, oldVNode) {
  if (equalLanguage(el, vnode) && equalValue(binding.value, binding.oldValue)) {
    return;
  }

  t(el, binding, vnode);
}

exports.default = {
  bind: bind,
  update: update
};